# Инициализация игрового поля 3x3.
# Каждая клетка изначально пуста (' ').
board = [[' ' for _ in range(3)] for _ in range(3)]

def display_board(board):
    """
    Отображает текущее состояние игрового поля в консоли.
    Поле форматируется с номерами строк и столбцов для удобства игрока.
    """
    print("\n  0   1   2") # Номера столбцов
    print("  -----------")
    for i, row in enumerate(board):
        # Используем f-строки для красивого вывода: номер строки, затем элементы через '|'.
        # Каждый элемент центрируется в 3 символах для выравнивания.
        print(f"{i} | {row[0]} | {row[1]} | {row[2]} |")
        print("  -----------")
    print() # Дополнительная пустая строка для лучшего отступа

def check_game_over(board):
    """
    Проверяет текущее состояние игрового поля на предмет завершения игры.
    Определяет, есть ли победитель (по горизонтали, вертикали или диагонали)
    или игра закончилась ничьей.

    Возвращает:
    - Символ победителя ('X' или 'O'), если кто-то выиграл.
    - 'Draw' (Ничья), если все клетки заполнены и нет победителя.
    - None, если игра еще продолжается.
    """
    
    # Возможные выигрышные комбинации (ряды, столбцы, диагонали)
    win_conditions = []

    # Горизонтальные линии
    for r in range(3):
        win_conditions.append([board[r][0], board[r][1], board[r][2]])
    
    # Вертикальные линии
    for c in range(3):
        win_conditions.append([board[0][c], board[1][c], board[2][c]])
    
    # Диагональные линии
    win_conditions.append([board[0][0], board[1][1], board[2][2]]) # Главная диагональ
    # ИСПРАВЛЕНИЕ: Убрана лишняя проверка '== player'
    win_conditions.append([board[0][2], board[1][1], board[2][0]]) # Побочная диагональ

    # Проверяем каждую выигрышную комбинацию
    for condition in win_conditions:
        if condition[0] != ' ' and condition[0] == condition[1] == condition[2]:
            return condition[0] # Возвращаем символ победителя ('X' или 'O')

    # Проверка на ничью: если нет победителя и все клетки заполнены
    is_board_full = True
    for row in board:
        if ' ' in row: # Если нашли хотя бы одну пустую клетку, доска не заполнена
            is_board_full = False
            break
            
    if is_board_full:
        return 'Draw' # Игра закончилась ничьей
        
    return None # Игра продолжается, победителя нет и есть пустые клетки

def get_player_move(player, board):
    """
    Запрашивает у текущего игрока координаты хода (строка и столбец).
    Обеспечивает проверку корректности ввода:
    - Координаты должны быть числами.
    - Координаты должны быть в диапазоне от 0 до 2.
    - Выбранная клетка должна быть пустой.

    Аргументы:
    - player (str): Символ текущего игрока ('X' или 'O').
    - board (list of list): Текущее состояние игрового поля.

    Возвращает:
    - tuple: Кортеж (строка, столбец) с корректными координатами хода.
    """
    while True:
        try:
            # Запрашиваем ввод строки и столбца
            row = int(input(f"Игрок {player}, введите номер строки (0-2): "))
            col = int(input(f"Игрок {player}, введите номер столбца (0-2): "))

            # Проверка диапазона координат
            if not (0 <= row <= 2 and 0 <= col <= 2):
                print("Ошибка: Координаты должны быть от 0 до 2. Попробуйте еще раз.")
            # Проверка, занята ли клетка
            elif board[row][col] != ' ':
                print("Ошибка: Эта клетка уже занята. Выберите другую.")
            else:
                return row, col # Возвращаем корректные координаты
        except ValueError:
            # Обработка ошибки, если пользователь ввел не число
            print("Ошибка: Введите, пожалуйста, число. Попробуйте еще раз.")

def play_tic_tac_toe():
    """
    Основная функция для запуска игры "Крестики-нолики".
    Управляет игровым циклом, сменой игроков и выводом результатов.
    """
    # Инициализация нового пустого поля для каждой новой игры
    game_board = [[' ' for _ in range(3)] for _ in range(3)]
    current_player = 'X' # Игрок 'X' всегда начинает первым
    game_result = None   # Переменная для хранения результата игры (победитель, ничья или None)
    
    print("Добро пожаловать в игру Крестики-нолики!")
    print("Игроки: X и O. Вводите координаты от 0 до 2 (строка, затем столбец).")

    # Основной игровой цикл: продолжается, пока игра не завершится
    while game_result is None:
        display_board(game_board) # Отображаем текущее состояние поля
        
        # Получаем и проверяем ход текущего игрока
        row, col = get_player_move(current_player, game_board)
        
        # Обновляем игровое поле ходом текущего игрока
        game_board[row][col] = current_player
        
        # Проверяем, не закончилась ли игра после текущего хода
        game_result = check_game_over(game_board)
        
        # Если игра еще не закончилась, меняем текущего игрока
        if game_result is None:
            current_player = 'O' if current_player == 'X' else 'X'
    
    # После завершения игры выводим финальное состояние поля и результат
    display_board(game_board)
    if game_result == 'Draw':
        print("Игра закончилась ничьей! Никто не победил.")
    elif game_result in ['X', 'O']:
        print(f"Поздравляем! Игрок {game_result} победил!")

# Точка входа в программу: запускаем игру, если скрипт выполняется напрямую
if __name__ == "__main__":
    play_tic_tac_toe()